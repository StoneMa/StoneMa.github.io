---
title: JAVA中的垃圾回收与内存分配-2
date: 2018-09-1 15:21:24
tags: [Java]
categories: Java技术
---
# 详解内存分配
通过上一篇文章，我们大题了解了变量和对象都是如何在栈内存和堆内存中分配的，那么我们继续了解。
还是老套路先上个图：
![heaptoStack](./heaptoStack.jpg)
栈，就如同它的名字一样，JVM中的栈内存也是一个后进先出LIFO的数据结构，JVM的垃圾回收器对于并非用new开辟的内存区域，就显得无能为力（来自《JAVA编程思想》第四版中文版P87）。垃圾回收器只知道释放那些由new分配的内存。所以为了应对这种情况，便有了finalize()方法。（详细内容，查资料）
要注意一点的是finalize()并不等同于C++中的析构函数。而Java中的垃圾回收符合下面的条件：
1. 对象可能不被垃圾回收
2. 垃圾回收并不等于“析构”
## 栈内存与栈操作
栈，常常与线程“联系”在一起，这是因为每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。
Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈和出栈。
### JVM栈之栈上分配
在JVM中，堆是线程共享的，因此堆上的对象对于各个线程都是共享和可见的，只要持有对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但对于垃圾收集器来说，无论筛选可回收对象，还是回收和整理内存都需要耗费时间。
如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。

## TLAB（Thread Local Allocation Buffer） 
"TLAB全称ThreadLocalAllocBuffer，是线程的一块私有内存，如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从[Eden](http://www.importnew.com/14630.html)区域申请一块继续使用，这个申请动作还是需要原子操作的。"----------
[简书：占小狼](https://www.jianshu.com/p/cd85098cca39)

TLAB拥有自己的私有内存，这样的好处就是每个线程都可以使用自己的专有指针来给自己的线程中的对象分配内存空间，线程间互不干扰。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。

## Java堆内存
![堆内存](./stackMemory.png)

* 对象分配
优先在Eden区分配
在JVM内存模型一文中, 我们大致了解了JVM年轻代堆内存可以划分为一块Eden区和两块Survivor区. 在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时, JVM发起一次Minor GC, 将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域, 如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区, 则会通过空间分配担保机制使对象提前进入老年代(空间分配担保见下).
* 大对象直接进入老年代
Serial和ParNew两款收集器提供了-XX:PretenureSizeThreshold的参数, 令大于该值的大对象直接在老年代分配, 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指 需要大量连续内存的Java对象, 如很长的字符串和数组), 因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间.

