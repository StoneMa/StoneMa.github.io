---
title: OpenCV图像处理总结
date: 2018-07-05 10:35:19
tags: [OpenCV, 灰度化, 特征提取, 全局特征, 局部特征]
categories: 图形学
mathjax: true
---

OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV用C++语言编写，主要用于图像处理。

基本方法包括但不限于：
* 图像灰度化
* 图像二值化
* 图像降噪，增强
* 图像特征提取
* 全局特征与局部特征

# 一些图像方面的基本知识：
1. 图像增强（image enhancement）
图像增强可以分为两大类: 频率域和空间域（频域和空域）。
* 前者把图像看成一种二维信号，对其进行基于二维傅里叶变换的信号增强。采用低通滤波（即只让低频信号通过）法，可去掉图中的噪声；采用高通滤波法，则可增强边缘等高频信号，使模糊的图片变得清晰。
* 后者空间域法中具有代表性的算法有局部求平均值法和中值滤波（取局部邻域中的中间像素值）法等，它们可用于去除或减弱噪声。
2. 灰度化
什么是灰度化？从字面意思来看就是将彩色图片变成灰色的。1：那么如何实现的呢？2：以及为什么要这样做呢？
首先我们知道常见的图像都是彩色图像，色彩的展示靠的是计算机计算出每个像素点的色值，比如一个像素位上的颜色是黄色，那么对于RGB三通道的图像来讲，就是R通道，G通道，B通道各有一个色值，然后将三者通过计算之后叠加，得到这个黄色的色值。当然我们上述说的都是RGB空间中的颜色处理，对于计算机上显示的彩色图像还有很多的颜色空间，比如HSV，和HLS等等。彩色图像中的每个像素的颜色有R、G、B三个分量决定，每个分量占一个字节，也就是8个bit，所以每个分量有$2^{8}=255$个颜色等级可以表示。所以一个24深度的RGB图像，每个像素点就有1600多万中色彩可以表示。如果我们想将其处理成灰色呢？

## **第一个问题，如何实现?**
在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。也就是说这时候图像的RGB三个通道的值都是相同的。对于图像的灰度化，有如下几种处理方法：
- 分量法
将彩色图像中的三分量的亮度作为三个灰度图像的灰度值，可根据应用需要选取一种灰度图像。
$$
f_{1}(i,j)=R(i,j) 
f_{2}(i,j)=G(i,j) 
f_{3}(i,j)=B(i,j)
其中f_{k}(i,j)(k=1,2,3)为转换后的灰度图像在图像坐标为(i,j)处的灰度值。
$$
- 最大值法
将彩色图像中的三分量亮度的最大值作为灰度图的灰度值。
$$
f(i,j)=max(R(i,j),G(i,j),B(i,j))
$$
- 平均值法
将彩色图像中的三分量亮度求平均得到一个灰度值。
$$
f(i,j)=(R(i,j)+G(i,j)+B(i,j)) /3
$$
- 加权平均法
根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像。
$$
f(i,j)=0.30R(i,j)+0.59G(i,j)+0.11B(i,j))
$$
- Opencv中图像灰度化处理：
在Opencv中可以通过以上几种方法的数值计算来得到灰度图像也可以通过opencv提供的颜色空间转换函数来得到。
Opencv封装灰度法：
```c++
    //彩色图转为灰度图方法调用
    cv::cvtColor(rgbMat, greyMat, CV_BGR2GRAY); 
```

## **第二个问题，为什么要这样灰度化?**
灰度图像不会消除图像的边缘信息，纹理信息，梯度信息等，所以使用灰度化后的图片可以完美保留这些有用的信息，同时还能节省图片的存储空间，（因为RGB压缩为一个通道来表示）所以这样的优的显而易见。
还有就是梯度信息对于识别物体来说很重要，所以我们可以把灰度图像看作图像的强度(Intensity)，来求一些梯度特征，比较常用的有 HOG，LBP，SIFT等等。

3. 像素点之间的关系
![opencv](./opencv1.png)
![opencv](./opencv2.png)

4. 像素梯度
图像梯度可以把图像看成二维离散函数，图像梯度其实就是这个二维离散函数的求导：
图像梯度: 
$$
G(x,y) = dx(i,j)+dy(i,j) \\
dx(i,j) = I(i+1,j) - I(i,j) \\
dy(i,j) = I(i,j+1) - I(i,j) \\
$$
其中，I是图像像素的值(如：RGB值)，(i,j)为像素的坐标。图像梯度一般也可以用中值差分：
$$
dx(i,j) = \frac{I(i+1,j)-I(i-1,j)}{2}; \\
dy(i,j) = \frac{I(i,j+1)-I(i,j-1)}{2};
$$
图像边缘一般都是通过对图像进行梯度运算来实现的。