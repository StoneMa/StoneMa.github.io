---
title: 求逆序对数量与归并排序
date: 2018-09-30 09:02:22
tags: [算法基础, 分治]
---
# 逆序对统计
最近写算法题的时候又遇到了这类问题:
``在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。``
``输入：1,2,3,4,5,6,7,0``
``输出： 7 ``
``可以从上面得知，逆序对分别为：<1,0> <2,0> <3,0> <4,0> <5,0> <6,0> <7,0> ``
这里问题，一个所有人都能想到的求解方法就是暴力搜索：用两层for循环将数组中的元素全部两两比较一遍，就能得到所有的逆序对数。
当然这样的做法也不是不行，但是效果是时间效率非常的低下，时间复杂度是O(n^2);在数据量很大的时候，响应时间会非常的久，这在算法上是不能接受的。
今天我们学习另一种思想：Divide And Conquer(分而治之--分治思想)，它的核心思想就是：大事化小，通过解决多个子问题来解决大问题。
这个问题的解决思路是和归并排序的思想类似的。
话不多说先看代码： （可以用归并排序来作为带入）

```Java
public class 数组逆向序对 {
    public static void main(String[] args) {
        数组逆向序对 nx = new 数组逆向序对();
        int[] a = {1, 2, 3, 4, 5, 6, 7, 0};
        System.out.println(nx.InversePairs(a));
    }

    public int InversePairs(int[] array) {
        int n = array.length;
        int[] temp = new int[n];
        long ans = MergeSortAndCount(array, 0, n - 1, temp);
        return (int) ans;
    }

    public long MergeSortAndCount(int[] array, int left, int right, int[] temp) {
        if (left >= right) return 0;
        int mid = (left + right) / 2;
        long count1 = MergeSortAndCount(array, left, mid, temp);
        long count2 = MergeSortAndCount(array, mid + 1, right, temp);
        long count3 = MergeAndCount(array, left, mid, right, temp);
        return (count1 + count2 + count3) % 1000000007;
    }

    public long MergeAndCount(int[] array, int left, int mid, int right, int[] temp) {
        int i = left;
        int j = mid + 1;
        int k = left;
        long cnt = 0;

        while (i <= mid && j <= right) {
            if (array[i] <= array[j]) {
                temp[k++] = array[i++];
            } else {
                temp[k++] = array[j++];
                cnt += mid - i + 1;    // key step
            }
        }

        while (i <= mid) temp[k++] = array[i++];
        while (j <= right) temp[k++] = array[j++];

        for (i = left; i <= right; ++i) {
            array[i] = temp[i];
        }
        return cnt;
    }

}
```
直接去读这段代码还是有些吃力的，主要有递归程序在，容易把我们绕晕，所以我们以归并排序作为基本思想，来慢慢解决这个问题：

# 归并排序